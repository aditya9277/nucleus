import { PrismaClient } from '@prisma/client';
import { ModelDefinition, ModelField } from '../types';

export class CRUDService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async create(modelName: string, data: any, userId?: string, model?: ModelDefinition): Promise<any> {
    try {
      // Add owner field if specified
      if (model?.ownerField && userId) {
        data[model.ownerField] = userId;
      }

      // Validate and transform data
      const validatedData = this.validateData(data, model);

      // Add timestamps
      const now = new Date().toISOString();
      validatedData.createdAt = now;
      validatedData.updatedAt = now;

      const record = await this.prisma.dynamicRecord.create({
        data: {
          modelName: modelName.toLowerCase(),
          data: JSON.stringify(validatedData),
          ownerId: userId || null
        }
      });

      return this.parseRecord(record);
    } catch (error: any) {
      throw new Error(`Failed to create record: ${error.message}`);
    }
  }

  async findAll(
    modelName: string, 
    userId?: string, 
    userRole?: string, 
    model?: ModelDefinition,
    filters?: any
  ): Promise<any[]> {
    try {
      const where: any = {
        modelName: modelName.toLowerCase()
      };

      // Apply ownership filter if user is not Admin
      if (userRole !== 'Admin' && model?.ownerField && userId) {
        where.ownerId = userId;
      }

      const records = await this.prisma.dynamicRecord.findMany({
        where,
        orderBy: { createdAt: 'desc' }
      });

      return records.map((record: any) => this.parseRecord(record));
    } catch (error: any) {
      throw new Error(`Failed to fetch records: ${error.message}`);
    }
  }

  async findById(modelName: string, id: string): Promise<any | null> {
    try {
      const record = await this.prisma.dynamicRecord.findFirst({
        where: {
          id,
          modelName: modelName.toLowerCase()
        }
      });

      return record ? this.parseRecord(record) : null;
    } catch (error: any) {
      throw new Error(`Failed to fetch record: ${error.message}`);
    }
  }

  async update(modelName: string, id: string, data: any, model?: ModelDefinition): Promise<any> {
    try {
      const existing = await this.findById(modelName, id);
      if (!existing) {
        throw new Error('Record not found');
      }

      // Extract only the data fields (exclude id and _meta)
      const { id: _, _meta, ...existingData } = existing;

      // Merge with existing data
      const updatedData = {
        ...existingData,
        ...data,
        updatedAt: new Date().toISOString()
      };

      // Validate
      const validatedData = this.validateData(updatedData, model);

      const record = await this.prisma.dynamicRecord.update({
        where: { id },
        data: {
          data: JSON.stringify(validatedData)
        }
      });

      return this.parseRecord(record);
    } catch (error: any) {
      throw new Error(`Failed to update record: ${error.message}`);
    }
  }

  async delete(modelName: string, id: string): Promise<void> {
    try {
      await this.prisma.dynamicRecord.delete({
        where: { id }
      });
    } catch (error: any) {
      throw new Error(`Failed to delete record: ${error.message}`);
    }
  }

  private parseRecord(record: any): any {
    const data = JSON.parse(record.data);
    // Remove 'id' from data to avoid conflicts with database id
    const { id, ...dataWithoutId } = data;
    return {
      id: record.id, // Use database ID
      ...dataWithoutId,
      _meta: {
        modelName: record.modelName,
        createdAt: record.createdAt,
        updatedAt: record.updatedAt
      }
    };
  }

  private validateData(data: any, model?: ModelDefinition): any {
    // Remove system fields that shouldn't be in the stored data
    const { id, _meta, ...cleanData } = data;
    
    if (!model) return cleanData;

    const validated: any = {};

    for (const field of model.fields) {
      // Skip 'id' field as it's auto-generated by the database
      if (field.name === 'id') {
        continue;
      }

      const value = cleanData[field.name];

      // Check required fields
      if (field.required && (value === undefined || value === null || value === '')) {
        throw new Error(`Field '${field.name}' is required`);
      }

      // Set default value
      if (value === undefined && field.default !== undefined) {
        validated[field.name] = field.default;
        continue;
      }

      // Skip undefined optional fields
      if (value === undefined) {
        continue;
      }

      // Validate type
      validated[field.name] = this.validateFieldType(field, value);
    }

    return validated;
  }

  private validateFieldType(field: ModelField, value: any): any {
    switch (field.type) {
      case 'string':
      case 'email':
        if (typeof value !== 'string') {
          throw new Error(`Field '${field.name}' must be a string`);
        }
        if (field.type === 'email' && !this.isValidEmail(value)) {
          throw new Error(`Field '${field.name}' must be a valid email`);
        }
        return value;

      case 'number':
        const num = Number(value);
        if (isNaN(num)) {
          throw new Error(`Field '${field.name}' must be a number`);
        }
        return num;

      case 'boolean':
        if (typeof value === 'boolean') return value;
        if (value === 'true') return true;
        if (value === 'false') return false;
        throw new Error(`Field '${field.name}' must be a boolean`);

      case 'date':
        const date = new Date(value);
        if (isNaN(date.getTime())) {
          throw new Error(`Field '${field.name}' must be a valid date`);
        }
        return date.toISOString();

      case 'json':
        if (typeof value === 'object') return value;
        try {
          return JSON.parse(value);
        } catch {
          throw new Error(`Field '${field.name}' must be valid JSON`);
        }

      default:
        return value;
    }
  }

  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  async disconnect(): Promise<void> {
    await this.prisma.$disconnect();
  }
}
